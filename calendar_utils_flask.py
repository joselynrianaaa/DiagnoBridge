"""
Flask-compatible version of calendar_utils.py
This removes Streamlit dependencies (st.error, st.warning, etc.) and replaces with print/logging
"""

import os
import json
from datetime import datetime, timedelta
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

# Combined scopes for Calendar + Docs + Drive
SCOPES = [
    'https://www.googleapis.com/auth/calendar',
    'https://www.googleapis.com/auth/documents',
    'https://www.googleapis.com/auth/drive.file'
]

TOKEN_PATH = "token.json"
CREDENTIALS_PATH = "credentials.json"


def get_google_services():
    """Authenticate and return Google Calendar and Docs services"""
    creds = None

    # Ensure credentials file exists
    if not os.path.exists(CREDENTIALS_PATH):
        print("ERROR: Missing credentials.json. Create an OAuth Desktop App client in Google Cloud Console.")
        print("1. Enable Calendar, Docs, and Drive APIs")
        print("2. Create OAuth client (type: Desktop)")
        print("3. Download as credentials.json")
        return None, None

    # Load token if available
    if os.path.exists(TOKEN_PATH):
        creds = Credentials.from_authorized_user_file(TOKEN_PATH, SCOPES)

    # Handle expired / missing credentials
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            try:
                creds.refresh(Request())
            except Exception as e:
                print(f"WARNING: Token refresh failed: {e}. Re-authenticating...")
                if os.path.exists(TOKEN_PATH):
                    os.remove(TOKEN_PATH)
                creds = None

        if not creds:
            try:
                flow = InstalledAppFlow.from_client_secrets_file(CREDENTIALS_PATH, SCOPES)
                creds = flow.run_local_server(
                    port=8765,
                    prompt='consent',
                    authorization_prompt_message="A browser window will open to authorize Google Calendar & Docs access.",
                    success_message="âœ… Authentication successful! You can close this tab.",
                    open_browser=True
                )
                # Save token
                with open(TOKEN_PATH, 'w') as token:
                    token.write(creds.to_json())
                print("âœ… Google services authenticated successfully!")
            except Exception as e:
                print(f"ERROR: Authentication failed: {e}")
                return None, None

    try:
        calendar_service = build('calendar', 'v3', credentials=creds)
        docs_service = build('docs', 'v1', credentials=creds)
        return calendar_service, docs_service
    except Exception as e:
        print(f"ERROR: Failed to initialize services: {e}")
        return None, None


def get_calendar_service():
    """Backward-compatible function (Calendar only)"""
    calendar_service, _ = get_google_services()
    return calendar_service


def create_medical_report_doc(docs_service, patient_name, report_content):
    """Create a formatted Google Doc - SIMPLE VERSION THAT WORKS"""
    if not docs_service:
        return None

    try:
        # Create the document
        title = f"Medical Report - {patient_name} - {datetime.now().strftime('%Y-%m-%d %H:%M')}"
        doc = docs_service.documents().create(body={'title': title}).execute()
        doc_id = doc.get('documentId')
        
        # Prepare formatted content with headers
        date_str = datetime.now().strftime("%B %d, %Y at %I:%M %p")
        
        # Build document content
        full_text = f"""MEDICAL REPORT

Patient: {patient_name}
Date: {date_str}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

{report_content}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

This report was generated by DocAssist AI Medical Assistant.
For medical emergencies, contact emergency services immediately.
"""
        
        # Single request to insert ALL text at once
        requests = [{
            'insertText': {
                'location': {'index': 1},
                'text': full_text
            }
        }]
        
        # Execute the update
        docs_service.documents().batchUpdate(
            documentId=doc_id,
            body={'requests': requests}
        ).execute()
        
        # Return document info
        doc_url = f"https://docs.google.com/document/d/{doc_id}/edit"
        return {
            'id': doc_id,
            'url': doc_url,
            'title': title
        }
        
    except HttpError as e:
        print(f"ERROR: Failed to create document: {e}")
        return None


def create_appointment_with_doc(calendar_service, patient_name, description,
                                start_datetime, end_datetime, doc_url=None):
    """Create an appointment and attach Google Doc link"""
    if not calendar_service:
        return None

    start_iso = start_datetime.strftime('%Y-%m-%dT%H:%M:%S')
    end_iso = end_datetime.strftime('%Y-%m-%dT%H:%M:%S')

    full_description = f'Patient: {patient_name}\n\nNotes: {description}'
    if doc_url:
        full_description += f'\n\nğŸ“‹ Medical Report: {doc_url}\n(Click to view detailed report in Google Calendar)'

    event = {
        'summary': f'Medical Appointment - {patient_name}',
        'description': full_description,
        'start': {'dateTime': start_iso, 'timeZone': 'America/New_York'},
        'end': {'dateTime': end_iso, 'timeZone': 'America/New_York'},
        'reminders': {
            'useDefault': False,
            'overrides': [
                {'method': 'email', 'minutes': 24 * 60},
                {'method': 'popup', 'minutes': 30}
            ],
        },
    }

    if doc_url:
        event['attachments'] = [{
            'fileUrl': doc_url,
            'title': 'Medical Report',
            'mimeType': 'application/vnd.google-apps.document'
        }]

    try:
        return calendar_service.events().insert(calendarId='primary', body=event).execute()
    except HttpError as e:
        print(f"ERROR: Failed to create appointment: {e}")
        return None


def get_upcoming_appointments(service, max_results=10):
    """Fetch upcoming events"""
    if not service:
        return []
    try:
        now = datetime.utcnow().isoformat() + 'Z'
        events_result = service.events().list(
            calendarId='primary',
            timeMin=now,
            maxResults=max_results,
            singleEvents=True,
            orderBy='startTime'
        ).execute()
        return events_result.get('items', [])
    except HttpError as e:
        print(f"ERROR: Failed to retrieve appointments: {e}")
        return []


def check_appointment_conflicts(service, start_datetime, end_datetime):
    """Check for conflicting events"""
    if not service:
        return []
    try:
        time_min = start_datetime.strftime('%Y-%m-%dT%H:%M:%S') + '+05:30'
        time_max = end_datetime.strftime('%Y-%m-%dT%H:%M:%S') + '+05:30'
        events_result = service.events().list(
            calendarId='primary',
            timeMin=time_min,
            timeMax=time_max,
            singleEvents=True,
            orderBy='startTime'
        ).execute()
        return events_result.get('items', [])
    except HttpError as e:
        print(f"ERROR: Conflict check failed: {e}")
        return []

