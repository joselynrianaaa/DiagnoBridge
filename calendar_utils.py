import os
import json
import streamlit as st
from datetime import datetime, timedelta
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

# Combined scopes for Calendar + Docs + Drive
SCOPES = [
    'https://www.googleapis.com/auth/calendar',
    'https://www.googleapis.com/auth/documents',
    'https://www.googleapis.com/auth/drive.file'
]

TOKEN_PATH = "token.json"
CREDENTIALS_PATH = "credentials.json"


# ----------------------------------------------------------------------
# AUTHENTICATION: Unified Calendar + Docs authorization
# ----------------------------------------------------------------------
def get_google_services():
    """Authenticate and return Google Calendar and Docs services"""
    creds = None

    # Ensure credentials file exists
    if not os.path.exists(CREDENTIALS_PATH):
        st.error("Missing credentials.json. Create an OAuth **Desktop App** client in Google Cloud Console and download it here.")
        st.info("1ï¸âƒ£ Enable Calendar, Docs, and Drive APIs\n2ï¸âƒ£ Create OAuth client (type: Desktop)\n3ï¸âƒ£ Download as credentials.json")
        return None, None

    # Load token if available
    if os.path.exists(TOKEN_PATH):
        creds = Credentials.from_authorized_user_file(TOKEN_PATH, SCOPES)

    # Handle expired / missing credentials
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            try:
                creds.refresh(Request())
            except Exception as e:
                st.warning(f"Token refresh failed: {e}. Re-authenticating...")
                if os.path.exists(TOKEN_PATH):
                    os.remove(TOKEN_PATH)
                creds = None

        if not creds:
            try:
                # âœ… Use local server flow (no redirect_uri issues)
                flow = InstalledAppFlow.from_client_secrets_file(CREDENTIALS_PATH, SCOPES)
                creds = flow.run_local_server(
                    port=8765,                # Different from Streamlit port (8501)
                    prompt='consent',
                    authorization_prompt_message="A browser window will open to authorize Google Calendar & Docs access.",
                    success_message="âœ… Authentication successful! You can close this tab and return to DocAssist.",
                    open_browser=True
                )
                # Save token
                with open(TOKEN_PATH, 'w') as token:
                    token.write(creds.to_json())
                st.success("Google services authenticated successfully!")
            except Exception as e:
                st.error(f"Authentication failed: {e}")
                return None, None

    try:
        calendar_service = build('calendar', 'v3', credentials=creds)
        docs_service = build('docs', 'v1', credentials=creds)
        return calendar_service, docs_service
    except Exception as e:
        st.error(f"Failed to initialize services: {e}")
        return None, None


def get_calendar_service():
    """Backward-compatible function (Calendar only)"""
    calendar_service, _ = get_google_services()
    return calendar_service


# ----------------------------------------------------------------------
# GOOGLE DOCS INTEGRATION
# ----------------------------------------------------------------------
import re

import re

import re

def create_medical_report_doc(docs_service, patient_name, report_content):
    """Create a formatted Google Doc - SIMPLE VERSION THAT WORKS"""
    if not docs_service:
        return None

    try:
        # Create the document
        title = f"Medical Report - {patient_name} - {datetime.now().strftime('%Y-%m-%d %H:%M')}"
        doc = docs_service.documents().create(body={'title': title}).execute()
        doc_id = doc.get('documentId')
        
        # Prepare formatted content with headers
        date_str = datetime.now().strftime("%B %d, %Y at %I:%M %p")
        
        # Build document content
        full_text = f"""MEDICAL REPORT

Patient: {patient_name}
Date: {date_str}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

{report_content}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

This report was generated by DocAssist AI Medical Assistant.
For medical emergencies, contact emergency services immediately.
"""
        
        # Single request to insert ALL text at once
        requests = [{
            'insertText': {
                'location': {'index': 1},
                'text': full_text
            }
        }]
        
        # Execute the update
        docs_service.documents().batchUpdate(
            documentId=doc_id,
            body={'requests': requests}
        ).execute()
        
        # Now apply formatting in a SECOND batch update
        # This avoids index calculation issues
        format_requests = [
            # Bold the title "MEDICAL REPORT"
            {
                'updateTextStyle': {
                    'range': {
                        'startIndex': 1,
                        'endIndex': 16  # "MEDICAL REPORT\n"
                    },
                    'textStyle': {
                        'bold': True,
                        'fontSize': {'magnitude': 18, 'unit': 'PT'}
                    },
                    'fields': 'bold,fontSize'
                }
            },
            # Bold "Patient:" and "Date:" labels
            {
                'updateTextStyle': {
                    'range': {
                        'startIndex': 17,
                        'endIndex': 26  # "\nPatient:"
                    },
                    'textStyle': {'bold': True},
                    'fields': 'bold'
                }
            },
            # Style the entire document with better font
            {
                'updateTextStyle': {
                    'range': {
                        'startIndex': 1,
                        'endIndex': len(full_text) + 1
                    },
                    'textStyle': {
                        'fontSize': {'magnitude': 11, 'unit': 'PT'},
                        'weightedFontFamily': {'fontFamily': 'Arial'}
                    },
                    'fields': 'fontSize,weightedFontFamily'
                }
            }
        ]
        
        # Apply formatting
        try:
            docs_service.documents().batchUpdate(
                documentId=doc_id,
                body={'requests': format_requests}
            ).execute()
        except:
            # If formatting fails, document still exists with content
            pass
        
        # Return document info
        doc_url = f"https://docs.google.com/document/d/{doc_id}/edit"
        return {
            'id': doc_id,
            'url': doc_url,
            'title': title
        }
        
    except HttpError as e:
        st.error(f"Failed to create document: {e}")
        return None
    """Create a well-formatted Google Doc for the medical report"""
    if not docs_service:
        return None

    try:
        # Create the document
        title = f"Medical Report - {patient_name} - {datetime.now().strftime('%Y-%m-%d %H:%M')}"
        doc = docs_service.documents().create(body={'title': title}).execute()
        doc_id = doc.get('documentId')
        
        # Prepare the full document text first
        date_str = datetime.now().strftime("%B %d, %Y at %I:%M %p")
        
        # Build the complete document content as plain text
        full_text = f"""MEDICAL REPORT

Patient: {patient_name}
Date: {date_str}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

{report_content}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

This report was generated by DocAssist AI Medical Assistant.
For medical emergencies, please contact qualified healthcare professionals immediately.
"""
        
        # Single request to insert all text at once
        requests = [
            {
                'insertText': {
                    'location': {
                        'index': 1
                    },
                    'text': full_text
                }
            }
        ]
        
        # Apply formatting AFTER text is inserted
        # Bold the title "MEDICAL REPORT"
        requests.append({
            'updateTextStyle': {
                'range': {
                    'startIndex': 1,
                    'endIndex': 16  # Length of "MEDICAL REPORT\n"
                },
                'textStyle': {
                    'bold': True,
                    'fontSize': {
                        'magnitude': 16,
                        'unit': 'PT'
                    }
                },
                'fields': 'bold,fontSize'
            }
        })
        
        # Apply document-wide formatting
        requests.append({
            'updateDocumentStyle': {
                'documentStyle': {
                    'defaultHeaderId': '',
                    'defaultFooterId': '',
                    'marginTop': {
                        'magnitude': 72,
                        'unit': 'PT'
                    },
                    'marginBottom': {
                        'magnitude': 72,
                        'unit': 'PT'
                    },
                    'marginLeft': {
                        'magnitude': 72,
                        'unit': 'PT'
                    },
                    'marginRight': {
                        'magnitude': 72,
                        'unit': 'PT'
                    }
                },
                'fields': 'marginTop,marginBottom,marginLeft,marginRight'
            }
        })
        
        # Execute the batch update
        docs_service.documents().batchUpdate(
            documentId=doc_id,
            body={'requests': requests}
        ).execute()
        
        # Return document info
        doc_url = f"https://docs.google.com/document/d/{doc_id}/edit"
        return {
            'id': doc_id,
            'url': doc_url,
            'title': title
        }
        
    except HttpError as e:
        st.error(f"Failed to create document: {e}")
        return None
    """Create a professional, formatted Google Doc medical report (no markdown errors)"""
    if not docs_service:
        return None

    try:
        # 1ï¸âƒ£ Create new document
        title = f"Medical Report - {patient_name} - {datetime.now().strftime('%Y-%m-%d %H:%M')}"
        doc = docs_service.documents().create(body={'title': title}).execute()
        doc_id = doc.get('documentId')
        date_str = datetime.now().strftime("%B %d, %Y at %I:%M %p")

        # Helper to append text at end safely
        def insert_text_block(text):
            return {"insertText": {"endOfSegmentLocation": {}, "text": text}}

        def insert_heading(text, level=2):
            return [
                insert_text_block(text + "\n"),
                {
                    "updateParagraphStyle": {
                        "range": {"segmentId": ""},
                        "paragraphStyle": {"namedStyleType": f"HEADING_{min(level, 2)}"},
                        "fields": "namedStyleType",
                    }
                },
            ]

        # 2ï¸âƒ£ Header and divider
        header = f"MEDICAL REPORT\n\nPatient: {patient_name}\nDate: {date_str}\n\n"
        divider = "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n"

        requests = [
            insert_text_block(header),
            insert_text_block(divider),
        ]

        # 3ï¸âƒ£ Clean markdown markers and split into lines
        clean_report = re.sub(r"[*_`#]", "", report_content)
        lines = clean_report.splitlines()

        for line in lines:
            clean_line = line.strip()
            if not clean_line:
                continue

            # Uppercase sections become headings
            if clean_line.isupper() and len(clean_line) > 4:
                requests.extend(insert_heading(clean_line, 2))
            else:
                requests.append(insert_text_block(clean_line + "\n"))

        # 4ï¸âƒ£ Footer
        footer = (
            "\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
            "This report was generated by DocAssist AI Medical Assistant.\n"
            "For medical emergencies, please contact qualified healthcare professionals immediately.\n"
        )
        requests.append(insert_text_block(footer))

        # 5ï¸âƒ£ Add formatting (font, spacing)
        requests.append({
            "updateParagraphStyle": {
                "range": {"segmentId": ""},
                "paragraphStyle": {
                    "lineSpacing": 150,  # 1.5x line spacing
                    "spaceAbove": {"magnitude": 10, "unit": "PT"},
                    "spaceBelow": {"magnitude": 10, "unit": "PT"},
                },
                "fields": "lineSpacing,spaceAbove,spaceBelow"
            }
        })
        requests.append({
            "updateTextStyle": {
                "range": {"segmentId": ""},
                "textStyle": {
                    "fontSize": {"magnitude": 12, "unit": "PT"},
                    "weightedFontFamily": {"fontFamily": "Arial"}
                },
                "fields": "fontSize,weightedFontFamily"
            }
        })

        # 6ï¸âƒ£ Batch update safely
        docs_service.documents().batchUpdate(documentId=doc_id, body={"requests": requests}).execute()

        # 7ï¸âƒ£ Return document info
        doc_url = f"https://docs.google.com/document/d/{doc_id}/edit"
        return {"id": doc_id, "url": doc_url, "title": title}

    except HttpError as e:
        st.error(f"Failed to create document: {e}")
        return None
    """Create a formatted Google Doc with automatic Markdown formatting (safe index-free version)"""
    if not docs_service:
        return None

    try:
        # 1ï¸âƒ£ Create new document
        title = f"Medical Report - {patient_name} - {datetime.now().strftime('%Y-%m-%d %H:%M')}"
        doc = docs_service.documents().create(body={'title': title}).execute()
        doc_id = doc.get('documentId')
        date_str = datetime.now().strftime("%B %d, %Y at %I:%M %p")

        def insert_text_block(text):
            """Helper: safely insert text at end of doc"""
            return {"insertText": {"endOfSegmentLocation": {}, "text": text}}

        def insert_heading(text, level=2):
            """Helper: insert a heading"""
            return [
                insert_text_block(text + "\n"),
                {
                    "updateParagraphStyle": {
                        "range": {"segmentId": "", "startIndex": 1, "endIndex": 1},
                        "paragraphStyle": {"namedStyleType": f"HEADING_{min(level, 2)}"},
                        "fields": "namedStyleType",
                    }
                },
            ]

        requests = []

        # 2ï¸âƒ£ Header
        header = f"MEDICAL REPORT\n\nPatient: {patient_name}\nDate: {date_str}\n\n"
        divider = "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n"
        requests.append(insert_text_block(header))
        requests.append(insert_text_block(divider))

        # 3ï¸âƒ£ Parse Markdown inline formatting
        lines = report_content.splitlines()

        for line in lines:
            clean_line = line.strip()
            if not clean_line:
                continue

            # Headings
            if re.match(r"^#+\s", clean_line):
                level = clean_line.count("#")
                text = re.sub(r"^#+\s*", "", clean_line)
                requests.extend(insert_heading(text, level))
                continue

            # Uppercase section headers (e.g., PRESENTING SYMPTOMS)
            if clean_line.isupper() and len(clean_line) > 5:
                requests.extend(insert_heading(clean_line, 2))
                continue

            # Inline Markdown conversion
            plain_text = re.sub(r"[*_`#]", "", clean_line)
            requests.append(insert_text_block(plain_text + "\n"))

            # Apply inline styles after inserting
            bold_matches = list(re.finditer(r"\*\*(.*?)\*\*", clean_line))
            italic_matches = list(re.finditer(r"\*(.*?)\*", clean_line))
            for m in bold_matches:
                requests.append({
                    "updateTextStyle": {
                        "range": {"segmentId": "", "startIndex": 1, "endIndex": 1},
                        "textStyle": {"bold": True},
                        "fields": "bold"
                    }
                })
            for m in italic_matches:
                requests.append({
                    "updateTextStyle": {
                        "range": {"segmentId": "", "startIndex": 1, "endIndex": 1},
                        "textStyle": {"italic": True},
                        "fields": "italic"
                    }
                })

        # 4ï¸âƒ£ Footer
        footer = (
            "\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
            "This report was generated by DocAssist AI Medical Assistant.\n"
            "For medical emergencies, please contact qualified healthcare professionals immediately.\n"
        )
        requests.append(insert_text_block(footer))

        # 5ï¸âƒ£ Batch update safely
        docs_service.documents().batchUpdate(documentId=doc_id, body={"requests": requests}).execute()

        # 6ï¸âƒ£ Return info
        doc_url = f"https://docs.google.com/document/d/{doc_id}/edit"
        return {"id": doc_id, "url": doc_url, "title": title}

    except HttpError as e:
        st.error(f"Failed to create document: {e}")
        return None

    """Create a styled Google Doc with Markdown (bold, italic, headings) rendered cleanly"""
    if not docs_service:
        return None

    try:
        # 1ï¸âƒ£ Create new document
        title = f"Medical Report - {patient_name} - {datetime.now().strftime('%Y-%m-%d %H:%M')}"
        doc = docs_service.documents().create(body={'title': title}).execute()
        doc_id = doc.get('documentId')
        date_str = datetime.now().strftime("%B %d, %Y at %I:%M %p")

        # 2ï¸âƒ£ Start with header text
        header_text = f"MEDICAL REPORT\n\nPatient: {patient_name}\nDate: {date_str}\n\n"
        divider = "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n"

        requests = [
            # Main title
            {"insertText": {"location": {"index": 1}, "text": header_text}},
            {
                "updateParagraphStyle": {
                    "range": {"startIndex": 1, "endIndex": len("MEDICAL REPORT")},
                    "paragraphStyle": {"namedStyleType": "HEADING_1"},
                    "fields": "namedStyleType"
                }
            },
            {"insertText": {"location": {"index": len(header_text)+1}, "text": divider}},
        ]

        # 3ï¸âƒ£ Split report into lines and format dynamically
        current_index = len(header_text) + len(divider) + 1

        def apply_markdown_formatting(text, start_offset):
            """
            Parses markdown patterns (**bold**, *italic*, ## Heading)
            and returns Docs API style requests for each match.
            """
            format_reqs = []

            # Headings
            if re.match(r"^#+\s", text):
                level = text.count("#")
                clean_text = re.sub(r"^#+\s*", "", text)
                format_reqs.append({
                    "insertText": {"location": {"index": start_offset}, "text": clean_text + "\n"}
                })
                format_reqs.append({
                    "updateParagraphStyle": {
                        "range": {
                            "startIndex": start_offset,
                            "endIndex": start_offset + len(clean_text)
                        },
                        "paragraphStyle": {"namedStyleType": f"HEADING_{min(level, 2)}"},
                        "fields": "namedStyleType"
                    }
                })
                return format_reqs, len(clean_text) + 1

            # Inline markdown: bold + italic
            pos = 0
            while pos < len(text):
                bold_match = re.search(r"\*\*(.+?)\*\*", text[pos:])
                italic_match = re.search(r"\*(.+?)\*", text[pos:]) if not bold_match else None

                if not bold_match and not italic_match:
                    # Plain text
                    format_reqs.append({
                        "insertText": {"location": {"index": start_offset}, "text": text[pos:] + "\n"}
                    })
                    start_offset += len(text[pos:]) + 1
                    break

                # Use whichever match appears first
                match = bold_match or italic_match
                is_bold = bool(bold_match)
                start, end = match.span()
                before_text = text[pos:start]
                formatted_text = match.group(1)

                # Insert text before the formatting
                if before_text:
                    format_reqs.append({
                        "insertText": {"location": {"index": start_offset}, "text": before_text}
                    })
                    start_offset += len(before_text)

                # Insert the formatted text
                format_reqs.append({
                    "insertText": {"location": {"index": start_offset}, "text": formatted_text}
                })
                format_reqs.append({
                    "updateTextStyle": {
                        "range": {
                            "startIndex": start_offset,
                            "endIndex": start_offset + len(formatted_text)
                        },
                        "textStyle": {"bold": is_bold, "italic": not is_bold},
                        "fields": "bold,italic"
                    }
                })
                start_offset += len(formatted_text)
                pos += end

            return format_reqs, start_offset

        # 4ï¸âƒ£ Process each line
        for line in report_content.splitlines():
            clean_line = line.strip()
            if not clean_line:
                continue

            # Section dividers or headings (e.g., ALL CAPS)
            if clean_line.isupper() and len(clean_line) > 4:
                requests.append({
                    "insertText": {"location": {"index": current_index}, "text": f"\n{clean_line}\n"}
                })
                requests.append({
                    "updateParagraphStyle": {
                        "range": {
                            "startIndex": current_index,
                            "endIndex": current_index + len(clean_line)
                        },
                        "paragraphStyle": {"namedStyleType": "HEADING_2"},
                        "fields": "namedStyleType"
                    }
                })
                current_index += len(clean_line) + 2
                continue

            # Parse Markdown inline formatting
            reqs, new_index = apply_markdown_formatting(clean_line, current_index)
            requests.extend(reqs)
            current_index = new_index + 1  # small gap between lines

        # 5ï¸âƒ£ Footer
        footer_text = (
            "\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
            "This report was generated by DocAssist AI Medical Assistant.\n"
            "For medical emergencies, please contact qualified healthcare professionals immediately.\n"
        )
        requests.append({"insertText": {"location": {"index": current_index}, "text": footer_text}})
        requests.append({
            "updateTextStyle": {
                "range": {
                    "startIndex": current_index,
                    "endIndex": current_index + len(footer_text)
                },
                "textStyle": {"italic": True, "foregroundColor": {"color": {"rgbColor": {"red": 0.2, "green": 0.2, "blue": 0.2}}}},
                "fields": "italic,foregroundColor"
            }
        })

        # 6ï¸âƒ£ Batch update
        docs_service.documents().batchUpdate(documentId=doc_id, body={"requests": requests}).execute()

        doc_url = f"https://docs.google.com/document/d/{doc_id}/edit"
        return {"id": doc_id, "url": doc_url, "title": title}

    except HttpError as e:
        st.error(f"Failed to create document: {e}")
        return None

    """Create a well-formatted Google Doc for the medical report"""
    if not docs_service:
        return None

    try:
        # 1ï¸âƒ£ Create the Google Doc
        title = f"Medical Report - {patient_name} - {datetime.now().strftime('%Y-%m-%d %H:%M')}"
        doc = docs_service.documents().create(body={'title': title}).execute()
        doc_id = doc.get('documentId')

        date_str = datetime.now().strftime("%B %d, %Y at %I:%M %p")

        # 2ï¸âƒ£ Build rich content
        requests = [
            # ---- Main Heading ----
            {
                "insertText": {
                    "location": {"index": 1},
                    "text": "MEDICAL REPORT\n"
                }
            },
            {
                "updateParagraphStyle": {
                    "range": {"startIndex": 1, "endIndex": 40},
                    "paragraphStyle": {"namedStyleType": "HEADING_1"},
                    "fields": "namedStyleType"
                }
            },

            # ---- Patient Info Section ----
            {
                "insertText": {
                    "location": {"index": 1},
                    "text": f"\nPatient: {patient_name}\nDate: {date_str}\n\n"
                }
            },
            # Bold 'Patient:' and 'Date:'
            {
                "updateTextStyle": {
                    "range": {"startIndex": 41, "endIndex": 49},
                    "textStyle": {"bold": True},
                    "fields": "bold"
                }
            },
            {
                "updateTextStyle": {
                    "range": {"startIndex": 50, "endIndex": 55 + len(patient_name)},
                    "textStyle": {"bold": False},
                    "fields": "bold"
                }
            },
            {
                "updateTextStyle": {
                    "range": {"startIndex": 56 + len(patient_name), "endIndex": 61 + len(patient_name)},
                    "textStyle": {"bold": True},
                    "fields": "bold"
                }
            },

            # ---- Divider ----
            {
                "insertText": {
                    "location": {"index": 1},
                    "text": "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n"
                }
            },
        ]

        # 3ï¸âƒ£ Parse your AI-generated report and enhance readability
        # Automatically identify lines with '**' or all-caps words and style them
        lines = report_content.splitlines()
        current_index = 200  # Start writing after header spacing
        for line in lines:
            clean_line = line.strip()
            if not clean_line:
                continue

            # Add newline before section headings
            if clean_line.isupper() or clean_line.startswith("##"):
                requests.append({
                    "insertText": {
                        "location": {"index": current_index},
                        "text": f"\n{clean_line}\n"
                    }
                })
                requests.append({
                    "updateParagraphStyle": {
                        "range": {"startIndex": current_index, "endIndex": current_index + len(clean_line)},
                        "paragraphStyle": {"namedStyleType": "HEADING_2"},
                        "fields": "namedStyleType"
                    }
                })
                current_index += len(clean_line) + 2
            else:
                # Regular body text
                requests.append({
                    "insertText": {
                        "location": {"index": current_index},
                        "text": clean_line + "\n"
                    }
                })
                current_index += len(clean_line) + 1

        # ---- Footer ----
        footer_text = (
            "\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
            "This report was generated by *DocAssist AI Medical Assistant.*\n"
            "For medical emergencies, please contact qualified healthcare professionals immediately."
        )
        requests.append({
            "insertText": {
                "location": {"index": current_index},
                "text": footer_text
            }
        })
        requests.append({
            "updateTextStyle": {
                "range": {"startIndex": current_index, "endIndex": current_index + len(footer_text)},
                "textStyle": {"italic": True, "foregroundColor": {"color": {"rgbColor": {"red": 0.2, "green": 0.2, "blue": 0.2}}}},
                "fields": "italic,foregroundColor"
            }
        })

        # 4ï¸âƒ£ Execute in one batch
        docs_service.documents().batchUpdate(documentId=doc_id, body={"requests": requests}).execute()

        # 5ï¸âƒ£ Return doc info
        doc_url = f"https://docs.google.com/document/d/{doc_id}/edit"
        return {"id": doc_id, "url": doc_url, "title": title}

    except HttpError as e:
        st.error(f"Failed to create document: {e}")
        return None

# ----------------------------------------------------------------------
# GOOGLE CALENDAR INTEGRATION
# ----------------------------------------------------------------------
def create_appointment_with_doc(calendar_service, patient_name, description,
                                start_datetime, end_datetime, doc_url=None):
    """Create an appointment and attach Google Doc link"""
    if not calendar_service:
        return None

    start_iso = start_datetime.strftime('%Y-%m-%dT%H:%M:%S')
    end_iso = end_datetime.strftime('%Y-%m-%dT%H:%M:%S')

    full_description = f'Patient: {patient_name}\n\nNotes: {description}'
    if doc_url:
        full_description += f'\n\nğŸ“‹ Medical Report: {doc_url}\n(Click to view detailed report)'

    event = {
        'summary': f'Medical Appointment - {patient_name}',
        'description': full_description,
        'start': {'dateTime': start_iso, 'timeZone': 'Asia/Kolkata'},
        'end': {'dateTime': end_iso, 'timeZone': 'Asia/Kolkata'},
        'reminders': {
            'useDefault': False,
            'overrides': [
                {'method': 'email', 'minutes': 24 * 60},
                {'method': 'popup', 'minutes': 30}
            ],
        },
    }

    if doc_url:
        event['attachments'] = [{
            'fileUrl': doc_url,
            'title': 'Medical Report',
            'mimeType': 'application/vnd.google-apps.document'
        }]

    try:
        return calendar_service.events().insert(calendarId='primary', body=event).execute()
    except HttpError as e:
        st.error(f"Failed to create appointment: {e}")
        return None


def get_upcoming_appointments(service, max_results=10):
    """Fetch upcoming events"""
    if not service:
        return []
    try:
        now = datetime.utcnow().isoformat() + 'Z'
        events_result = service.events().list(
            calendarId='primary',
            timeMin=now,
            maxResults=max_results,
            singleEvents=True,
            orderBy='startTime'
        ).execute()
        return events_result.get('items', [])
    except HttpError as e:
        st.error(f"Failed to retrieve appointments: {e}")
        return []


def check_appointment_conflicts(service, start_datetime, end_datetime):
    """Check for conflicting events"""
    if not service:
        return []
    try:
        time_min = start_datetime.strftime('%Y-%m-%dT%H:%M:%S') + '+05:30'
        time_max = end_datetime.strftime('%Y-%m-%dT%H:%M:%S') + '+05:30'
        events_result = service.events().list(
            calendarId='primary',
            timeMin=time_min,
            timeMax=time_max,
            singleEvents=True,
            orderBy='startTime'
        ).execute()
        return events_result.get('items', [])
    except HttpError as e:
        st.error(f"Conflict check failed: {e}")
        return []


# ----------------------------------------------------------------------
# UTILITIES
# ----------------------------------------------------------------------
def reset_calendar_auth():
    """Force reset authentication"""
    if os.path.exists(TOKEN_PATH):
        os.remove(TOKEN_PATH)
        st.success("Authentication reset. Please reauthorize when prompted.")
    else:
        st.info("No existing authentication token found.")


def share_doc_with_email(docs_service, doc_id, email, role='reader'):
    """Share document via Drive permissions"""
    try:
        drive_service = build('drive', 'v3', credentials=docs_service._http.credentials)
        permission = {'type': 'user', 'role': role, 'emailAddress': email}
        drive_service.permissions().create(
            fileId=doc_id, body=permission, sendNotificationEmail=True
        ).execute()
        return True
    except Exception as e:
        st.error(f"Failed to share document: {e}")
        return False
